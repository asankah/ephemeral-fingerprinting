<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8">
    <title>Ephemeral Fingerprinting</title>
    <meta name="generator" content="pandoc">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="theme-color" content="#157878">
    <meta name="author" content="Asanka Herath">
    <meta name="dcterms.date" content="2020-03-01">
    <meta name="description" content="A description of what ephemeral fingerprinting is and some guidelines for spotting them during web API reviews.">
    <meta name="keywords" content="fingerprinting, ephemeral fingerprinting">
    <link rel="stylesheet" href="stylesheets/article.css">
    <link rel="stylesheet" href="stylesheets/normalize.css">
    <link rel="stylesheet" href="stylesheets/highlight.css">
    <script src="javascripts/highlight.pack.js"></script>
    <script>hljs.initHighlightingOnLoad();</script>
  </head>
  <body>
    <section class="buttons">
      <a href="https://asankah.github.io/" class="btn">Home</a>
      <a href="https://github.com/asankah/ephemeral-fingerprinting" class="btn">View on GitHub</a>
      <a href="https://github.com/asankah/ephemeral-fingerprinting/issues" class="btn">Issues</a>
      <a href="https://github.com/asankah/ephemeral-fingerprinting/issues/new" class="btn">New Issue</a>
    </section>
    <section class="main-content">
<h1 id="ephemeral-fingerprinting-on-the-web">Ephemeral Fingerprinting On The Web</h1>
<h2 id="background">Background</h2>
<p>TL;DR:</p>
<ul>
<li>
<p>Any ephemeral low-entropy web observable property whose changes are concurrently observable by multiple sites can lead to cross site identity joining.</p>
</li>
<li>
<p>This method of identity joining does not require coordination between multiple first parties. A single third party embedded within multiple first parties can also use this method.</p>
</li>
</ul>
<p><img src="images/isolation-boundaries.png" alt="diagram of site isolation boundaries with overlap" /></p>
<p><strong>Example 1</strong>: Two sites observe a sequence of device orientation changes at times ùíï‚ÇÄ, ùíï‚ÇÅ,ùíï‚ÇÇ.</p>
<p>All sites on the same UA instance share a clock and therefore can agree on the timestamps with a small margin of error. The triplet ùíï‚ÇÄ, ùíï‚ÇÅ,ùíï‚ÇÇ has a high probability of uniquely identifying the user.</p>
<p>Signals considered for ephemeral fingerprinting may not be highly identifying by themselves. The <a href="https://github.com/bslassey/privacy-budget">privacy budget proposal</a> does not adequately account for fingerprinting based on concurrent observations of low entropy signals.</p>
<p>Device orientation, from our earlier example, can take one of two values (portrait or landscape), and is unstable. Thus a single sample of device orientation carries almost no information. I.e. Normalized Mutual Information (NMI) between the user and the device orientation reading is approximately zero. However timestamps corresponding to orientation changes could have identifying levels of entropy.</p>
<p>_One or more low entropy signals observed concurrently can be used to identify a user with a high degree of confidence. _Let‚Äôs call these <strong><em>ephemeral fingerprints</em></strong>. This document discusses two types:</p>
<ol>
<li><p><em>The sequence of timestamps ‚Äî possibly coarse ‚Äî of a volatile surface can be used for identification</em>. Let‚Äôs call these <strong>correlated events</strong>.</p></li>
<li><p><em>A stream of observations of a volatile surface can be identifying</em>. Let‚Äôs call these <strong>unique event streams</strong>.</p></li>
</ol>
<p>These are not new. For example, this is discussed by Van Goethem et. al. <sup><a href="#van-goethem">[1]</a></sup> who calls these ‚ÄúCross-Session Events‚Äù (¬ß 5 of linked paper). Potential ephemeral fingerprinting surfaces also get flagged during standardization discussions ( <a href="https://github.com/w3c/mediacapture-main/issues/403">Example: Polling enumerateDevices</a>, <a href="https://lists.w3.org/Archives/Public/public-privacy/2013JanMar/0007.html">Example: Ambient light events</a>).</p>
<h3 id="other-examples">Other Examples</h3>
<ul>
<li>
<code>Accelerometer</code> properties.
</li>
<li>
<code>Sensor</code>, <code>onreading</code> event.
</li>
<li>
<code>BatteryManager.onlevelchange</code> : Deprecated but still shipping.
</li>
<li>
<code>Bluetooth.onadvertisementreceived</code>
</li>
<li>
<code>BroadcastChannel</code>, all events.
</li>
<li>
<code>MediaDevices.devicechange</code> event.
</li>
<li>
<code>GlobalEventHandlers.onfocus</code> and <code>onblur</code> events can fire simultaneously when switching between two browser windows.
</li>
</ul>
<h2 id="mitigations">Mitigations</h2>
<h3 id="permissions">Permissions</h3>
<p><strong>Goal:</strong> Require informed consent from users.</p>
<p>There‚Äôs precedent for considering permissions <sup><a href="#permission-methods">[2]</a></sup> to be sufficient mitigation for similar issues. For example, the Media Capture API specification includes the following:</p>
<blockquote>
<p>For origins to which permission has been granted, the devicechange event will be emitted across browsing contexts and origins each time a new media device is added or removed; user agents can mitigate the risk of correlation of browsing activity across origins by fuzzing the timing of these events.</p>
</blockquote>
<p style="text-align: right">
From ¬ß15 of <a href="https://w3c.github.io/mediacapture-main/#privacy-and-security-considerations">Media Capture and Streams API</a> specification.</p>
<p><strong>Pros</strong></p>
<ul>
<li>
Prevents drive-by fingerprinting.
</li>
</ul>
<p><strong>Cons</strong></p>
<ul>
<li>
<p>UI for permissions don‚Äôt disclose the fact that all sites that have been granted access to the same resource can synchronize identifiers as a side-effect.</p>
</li>
<li>
<p>Doesn‚Äôt prevent identity joining once permission is granted.</p>
</li>
</ul>
<h3 id="fuzzing-timing-of-events">Fuzzing Timing of Events</h3>
<p><strong>Goal</strong>: Deter correlation of events by injecting timing skew.</p>
<p>Mentioned in the snippet above from the Media Capture and Streams API and called out by Jeffrey Yasskin as a potential general mitigation in ‚Äúdesynchronize whole-browser events‚Äù in <a href="https://github.com/whatwg/html/issues/5215">this issue</a> filed against the WHATWG HTML specification.</p>
<p><strong>Pros</strong></p>
<ul>
<li>
Lowers confidence of identity equivalence.
</li>
</ul>
<p><strong>Cons</strong></p>
<ul>
<li>
<p>Precise timing may not be required. I.e. the lowered level of confidence could still be sufficient for most uses.</p>
</li>
<li>
<p>Doesn‚Äôt address unique event streams.</p>
</li>
</ul>
<h3 id="first-party-restriction-for-apis">First-Party Restriction for APIs</h3>
<p><strong>Goal</strong>: Deter identity correlation by third-party sites.</p>
<p>Restrict APIs to the origin of the <a href="https://html.spec.whatwg.org/multipage/browsers.html#top-level-browsing-context">top-level browsing context</a>.</p>
<p>The latter may choose to explicitly delegate access to the APIs via <a href="https://w3c.github.io/webappsec-feature-policy/">feature policies</a>. But third-party contexts can‚Äôt ‚Äúreach across‚Äù browsing contexts via correlation of cross context events or attributes that may be made available by the API.</p>
<p><strong>Pros</strong></p>
<ul>
<li>
Makes it a requirement that first-parties actively cooperate with other first-parties or third-parties. I.e. Good first-party + bad third-party = safe.
</li>
</ul>
<p><strong>Cons</strong></p>
<ul>
<li>
<p>Difficult to retrofit into existing APIs.</p>
</li>
<li>
<p>Browser-wide events and attributes are still visible to distinct top-level browsing contexts.</p>
</li>
<li>
<p>In practice top-level browsing contexts contain a fair amount of third party scripts which may access the same APIs. Furthermore there are financial incentives for first-parties to delegate API access to third-parties.</p>
</li>
</ul>
<h3 id="limit-api-access-to-visible-browsing-contexts">Limit API Access To Visible Browsing Contexts</h3>
<p><strong>Goal:</strong> Prevent background browsing contexts from skimming identifiable events.</p>
<p>The Page Visibility API defines the <a href="https://w3c.github.io/page-visibility/#visibility-states">visibility state of a document</a> as <code>visible</code> if the document is <em>‚Äúat least partially visible on at least one screen‚Äù</em>.</p>
<p>Restrict APIs to ‚Äî possibly top-level ‚Äî browsing context‚Äôs active document.</p>
<p><strong>Pros</strong></p>
<ul>
<li>
Is a convincing mitigation on mobile devices where only one top-level document can be visible at the same time.
</li>
</ul>
<p><strong>Cons</strong></p>
<ul>
<li>
<p>There could be multiple visible browsing contexts which still leaves the door open for identity correlation across site boundaries.</p>
</li>
<li>
<p>The fact that having more than one browsing context open at the same time is a privacy risk is quite surprising for users.</p>
</li>
</ul>
<h3 id="limit-events-to-focused-top-level-browsing-context">Limit Events To Focused Top-Level Browsing Context</h3>
<p><strong>Goal</strong>: Limit firing correlatable events to a single <a href="https://html.spec.whatwg.org/multipage/browsers.html#top-level-browsing-context">top-level browsing context</a>.</p>
<p>The HTML spec defines a concept of a <em><a href="https://html.spec.whatwg.org/multipage/interaction.html#currently-focused-area-of-a-top-level-browsing-context">currently focused area of a top-level browsing context</a></em>. As defined, every top level <a href="https://html.spec.whatwg.org/multipage/browsers.html#browsing-context">browsing context</a> has one regardless of visibility. A similar narrow concept could be introduced that recognizes the top level browsing context that has system input focus. There should be only one of these on a single device.</p>
<p><em>Let‚Äôs call the top-level browsing context that has system input focus as the</em> <strong>focused top-level browsing context</strong>.</p>
<p>New specifications could restrict browser-wide events to the focused top-level browsing context.</p>
<p><strong>Pros</strong></p>
<ul>
<li>
Likely fits in well with the intended usage model for most APIs.
</li>
</ul>
<p><strong>Cons</strong></p>
<ul>
<li>
Does not address event stream fingerprinting via polling.
</li>
</ul>
<h3 id="limit-api-access-to-focused-top-level-browsing-context">Limit API Access To Focused Top-Level Browsing Context</h3>
<p><strong>Goal</strong>: Limit access to sensitive APIs to a single <a href="https://html.spec.whatwg.org/multipage/browsers.html#top-level-browsing-context">top-level browsing context</a>.</p>
<p>Similar to the above, but addresses issues around polling by disallowing access to the entire API or sensitive attributes by restricting the entire API instead of just events.</p>
<p><strong>Pros</strong></p>
<ul>
<li>
Resilient to event stream fingerprinting via polling.
</li>
</ul>
<p><strong>Cons</strong></p>
<ul>
<li>
<p>Can‚Äôt be easily retrofitted to existing APIs since it requires defining behavior for ‚Äúdisabled‚Äù APIs.</p>
</li>
<li>
<p>May break critical use cases.</p>
</li>
</ul>
<h3 id="secure-context-restriction-and-control-via-feature-policy">Secure-Context Restriction and Control via Feature-Policy</h3>
<p>These should be pretty standard at this point.</p>
<p><strong>Pros</strong></p>
<ul>
<li>
Just makes sense.
</li>
</ul>
<p><strong>Cons</strong></p>
<ul>
<li>
Not sufficient by itself.
</li>
</ul>
<h2 id="spotting-ephemeral-fingerprinting-surfaces-in-web-specs">Spotting Ephemeral Fingerprinting Surfaces In Web Specs</h2>
<p><strong>Ephemeral fingerprints:</strong></p>
<ul>
<li>
<p>Require that multiple browsing contexts observe the same events or access the same volatile attribute.</p>
</li>
<li>
<p>These browsing contexts could involve a single third party in multiple first party contexts.</p>
</li>
<li>
<p>Does not require precise clocks nor agreement on the exact timestamps of the observed events. Depending on the fingerprintable surfaces involved the sequence of events could be identifiable by itself. Servers can roughly bucket observations by time periods, eliminating the need for client-side clocks.</p>
</li>
<li>
<p>Does not require an API to fire an event. A property with a volatile value that can be polled periodically is sufficient.</p>
</li>
</ul>
<h3 id="what-to-look-for">What to look for:</h3>
<ul>
<li>
<p>Events with external triggers. E.g. hardware based events.</p>
</li>
<li>
<p>Multiple distinct events that are fired in tandem to distinct browsing contexts. E.g. any processing model where multiple events are fired.</p>
</li>
<li>
<p>Volatile attributes that are visible across browsing contexts.</p>
</li>
<li>
<p>Volatile attributes that don‚Äôt share values across browsing contexts, but change simultaneously. E.g. Salting a volatile attribute is insufficient if its mutations can be correlated.</p>
</li>
</ul>
<h3 id="example">Example</h3>
<p>Consider <code>onfocus</code> and <code>onblur</code> events.</p>
<p>The <a href="https://html.spec.whatwg.org/multipage/interaction.html#focus-update-steps">focus update steps</a> involve firing up to three distinct events: <code>change</code> if the node losing focus is an <code>input</code> element, <code>focus</code>, and <code>blur</code>.</p>
<p>When focus traverses a browsing context boundary, these events may be fired simultaneously to two different browsing contexts. Browsers mitigate this by not firing <code>blur</code> for cross site tab switches, but they still fire <code>blur</code> when the browser itself goes out of focus. Thus identity can be correlated when switching browser windows.</p>
<h4 id="possible-mitigation">Possible Mitigation</h4>
<p>When the <em>new chain</em> and the <em>old chain</em><sup><a href="#chains">[3]</a></sup> are in different top-level browsing contexts whose active documents are not same-origin, queue but don‚Äôt fire <code>change</code> and <code>blur</code> events until focus returns to the old top-level browsing context.</p>
<h3 id="notes">Notes</h3>
<p><span id="van-goethem">[1]</span>: Van Goethem, T. and Joosen, W., 2017. One side-channel to bring them all and in the darkness bind them: Associating isolated browsing sessions. In <em>11th {USENIX} Workshop on Offensive Technologies ({WOOT} 17)</em>. (<a href="https://pdfs.semanticscholar.org/5814/9610a57cb4626918bf003b8bad25e740b1f4.pdf">PDF</a>)</p>
<p><span id="permission-methods">[2]</span>: Either via a legacy permissions prompt or explicitly requiring the use of the <a href="https://w3c.github.io/permissions/">Permissions API</a> in the spec for sensitive APIs.</p>
<p><span id="chains">[3]</span>: <em>New chain</em> and <em>old chain</em> are defined in <a href="https://html.spec.whatwg.org/multipage/interaction.html#focus-update-steps">focus update steps</a>.</p>

    </section>

  </body>
</html>
